# -*- coding: utf-8 -*-
"""Exploratory Data Analysis and Data Viz

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-0m6vW8tkO5-MCtsC7HWjqUG0Jprn5hJ

# **Task 1: Visually Exploring a Dataset**

**Project Overview: Crime Data Exploratory Data Analysis**

This project utilizes Exploratory Data Analysis (EDA) to examine a crime dataset from Kaggle. The goal is to uncover characteristics, patterns, and relationships within crime incidents, offenders, and victims, using interactive visualizations powered by Plotly and descriptive statistical techniques.


**1. Dataset Overview**
Source: Kaggle –  [Crime Data](https://www.kaggle.com/datasets/fatmanur12/crime-data)

To run this notebook: Download the crime_data.csv file manually from the Kaggle link above. Place the downloaded CSV file in the same directory as your Jupyter Notebook, or import to colab by running the import cell and selecting the file in your device.

**Main Columns:**

`Disposition:` Outcome of the case (e.g., CLOSED, ARRESTED).

`OffenderStatus:` Status of the offender (e.g., ARRESTED).

`Offender_Race:` Race of the offender.

`Offender_Gender:` Gender of the offender.

`Offender_Age:` Age of the offender.

`PersonType:` Type of person involved (e.g., VICTIM, OFFENDER).

`Victim_Race:` Race of the victim.

`Victim_Gender:` Gender of the victim.

`Victim_Age:` Age of the victim.

`Victim_Fatal_Status:` Whether the victim's status was fatal or non-fatal.

`Report Type:` Type of report (e.g., Supplemental Report, Incident Report).

`Category:` Category of the crime (e.g., Theft, Violence, Miscellaneous).

**Aim**

The aim of this analysis is to use visualizations to explore the crime_data dataset across various dimensions such as offender and victim demographics, crime categories, and temporal or geographical trends.

**Installation Instructions**

First, ensure you have Python installed, if you are using Google colab, you don't have to run this cell because all packages have already been installed. Then, open your terminal or command prompt (or a new cell in your Jupyter Notebook and run with `!`) and execute the following `pip` commands to install each package:
"""

# install pandas:
pip install pandas

# install pandas:
pip install plotly

# install matplotlib:
pip install matplotlib

# install seaborn:
pip install seaborn

"""**Import Statements**

Once installed, you can import them into your Jupyter Notebook (typically at the beginning of your script or notebook) using these standard conventions:
"""

import pandas as pd                # For working with tabular data and DataFrames
import numpy as np                 # For numerical operations and array manipulation
import plotly.express as px        # For creating high-level, interactive Plotly charts easily
import plotly.graph_objects as go  # For more granular control and custom interactive Plotly charts
import matplotlib.pyplot as plt    # For foundational plotting, customizations, and static plots
import seaborn as sns              # For aesthetically pleasing statistical plots and enhanced styles
import os                          # For interacting with the operating system, e.g., managing file paths
import io                          # Required for io.BytesIO

"""**Importing the Crime Data Dataset by Uploading from Your Local Machine (Colab)**

To load your `crime_data.csv` file into a Pandas DataFrame in Google Colab, you'll upload the file directly from your local system using Colab’s built-in file upload feature.

The code below opens a file picker for you to select the CSV file. Once uploaded, it is temporarily stored in the Colab environment, and can then be read using `pandas.read_csv()`.
"""

from google.colab import files
uploaded = files.upload()

"""**Parsing the uploaded file into a Pandas DataFrame**

The uploaded CSV file is read and converted into a Pandas DataFrame for further analysis. This allows for efficient data manipulation, exploration, and visualization using Python's data science libraries.



"""

try:
    # Get the filename from the uploaded dictionary
    filename = list(uploaded.keys())[0]
    # Read the uploaded file's content into a Pandas DataFrame.
    # io.BytesIO is used to treat the uploaded file's byte content as a file-like object.
    df = pd.read_csv(io.BytesIO(uploaded[filename]))
except pd.errors.EmptyDataError:
    # This block will not print anything as per request, but handles the error internally.
    # In a notebook, you might want to log this or set df to None.
    df = None
except Exception as e:
    # This block will not print anything as per request, but handles the error internally.
    # In a notebook, you might want to log this or set df to None.
    df = None

"""
**Initial Data Overview**

This section of the code performs an initial inspection of the loaded dataset to understand its structure, data types, and completeness. It generates beautified, interactive HTML tables for key summary statistics, making the initial data overview much more readable and visually appealing within a Jupyter Notebook environment.


* Column Information (Data Types and Non-Null Counts).
* Missing Values Count (df.isnull().sum()).

"""

# --- Beautify Column Information (from df.info() details) ---
print("\n--- Column Information (Data Types and Non-Null Counts) ---")
# Create a DataFrame from df.info() details
column_info = pd.DataFrame({
    'Column': df.columns,
    'Non-Null Count': df.count(), # df.count() gives non-nulls per column
    'Data Type': df.dtypes
})
# Reset index to make 'Column' a regular column if it became index
column_info = column_info.reset_index(drop=True)

display(
    column_info.style
    .set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#673AB7'), ('color', 'white'), ('font-weight', 'bold')]}, # Purple header
        {'selector': 'td', 'props': [('padding', '8px'), ('border', '1px solid #ddd')]},
        {'selector': 'table', 'props': [('width', '100%'), ('border-collapse', 'collapse')]}
    ])
    .background_gradient(cmap='PuBu', subset=['Non-Null Count']) # Gradient on non-null count
    .set_properties(**{'text-align': 'center'})
    .set_caption("Dataset Column Details")
    .hide(axis="index")
)

# --- Beautify df.describe() ---
print("\n--- Descriptive Statistics for Numerical Columns ---")
display(
    df.describe().style
    .background_gradient(cmap='YlGn', axis=1) # Apply gradient row-wise for better comparison
    .format("{:.2f}") # Format numerical values to 2 decimal places
    .set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#2196F3'), ('color', 'white'), ('font-weight', 'bold')]},
        {'selector': 'td', 'props': [('padding', '8px'), ('border', '1px solid #ddd')]},
        {'selector': 'table', 'props': [('width', '100%'), ('border-collapse', 'collapse')]}
    ])
    .set_caption("Descriptive Statistics")
)


# --- Beautify df.isnull().sum() ---
print("\n--- Missing Values Count ---")
missing_data = df.isnull().sum()
missing_data = missing_data[missing_data > 0].sort_values(ascending=False).reset_index()
missing_data.columns = ['Column', 'Missing Count']
missing_data['Percentage (%)'] = (missing_data['Missing Count'] / len(df)) * 100

if not missing_data.empty:
    display(
        missing_data.style
        .background_gradient(cmap='OrRd', subset=['Missing Count']) # Highlight higher missing counts
        .format({"Percentage (%)": "{:.2f}%"})
        .set_properties(**{'text-align': 'center'})
        .set_table_styles([
            {'selector': 'th', 'props': [('background-color', '#FF5722'), ('color', 'white'), ('font-weight', 'bold')]},
            {'selector': 'td', 'props': [('padding', '8px'), ('border', '1px solid #ddd')]},
            {'selector': 'table', 'props': [('width', '100%'), ('border-collapse', 'collapse')]}
        ])
        .set_caption("Columns with Missing Values")
        .hide(axis="index")
    )
else:
    print("No missing values found in the dataset.")

"""**1. Analysis: Distribution of Crime Categories**

This section aims to understand the prevalence of different crime types by analyzing the Category column. We use frequency counts and proportions as EDA techniques. The primary visualization is a Plotly Bar Chart (px.bar), which shows the number of incidents for each crime category, allowing for quick identification of the most common crimes.

**1.1. Data Cleaning and transformation**

This section cleans the 'Category' column by removing extra spaces, converting text to uppercase, and handling invalid 'NAN' strings. It then calculates the frequency and percentage of each crime category and displays the results in a styled summary table for easy interpretation.
"""

# --- CRITICAL: Robust Cleaning for 'Category' Column ---
# Apply strip() and upper() to ensure exact string matching and consistency
if 'Category' in df.columns:
    df['Category'] = df['Category'].astype(str).str.strip().str.upper()
    df['Category'] = df['Category'].replace('NAN', np.nan) # Convert 'NAN' string back to actual NaN

# --- Debugging: Print unique values after cleaning ---
print("\n--- Unique values for Category after cleaning ---")
print(f"Category unique: {df['Category'].dropna().unique().tolist()}")


# --- EDA Technique: Frequency counts and proportions for 'Category' ---
# Drop NaN values for accurate statistical calculations
df_clean_category = df.dropna(subset=['Category'])

# Count number of incidents per Category
category_counts = df_clean_category['Category'].value_counts().reset_index()
category_counts.columns = ['Category', 'Count']

# Calculate the proportions
category_counts['Percentage (%)'] = (category_counts['Count'] / category_counts['Count'].sum()) * 100

print("\n--- Summary of Crime Categories ---")
# Display the table with beautified formatting
display(
    category_counts.style
    .background_gradient(cmap='Blues', subset=['Count']) # Apply gradient to 'Count'
    .format({"Percentage (%)": "{:.2f}%"}) # Format percentage column
    .set_properties(**{'text-align': 'center'}) # Center align text
    .set_caption("Frequency and Proportion of Crime Categories") # Add a caption
    .set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#4CAF50'), ('color', 'white'), ('font-weight', 'bold')]},
        {'selector': 'td', 'props': [('padding', '8px'), ('border', '1px solid #ddd')]},
        {'selector': 'table', 'props': [('width', '100%'), ('border-collapse', 'collapse')]}
    ])
    .hide(axis="index") # Hide the default pandas index for a cleaner look
)

"""**1.2. Crime categorical distribution**

This bar chart visualizes the frequency of each crime category using unique colors. Count labels are placed above each bar for clarity, and styling is applied for better readability and presentation.
"""

# --- Visualization: Plotly Bar Chart for 'Category' distribution with Counts on Bars ---
print("\n--- Crime Category Bar Chart with Unique Colors and Counts ---")

fig_cat_incidents = px.bar(
    category_counts,
    x='Category',
    y='Count',
    color='Category',  # Each bar gets a unique color based on its category
    title='Crime Categories - Count of Incidents',
    template='plotly_white',
    opacity=1,  # Ensure full opacity
    text='Count'  # Add text labels from the 'Count' column
)

# Customize layout for better readability and aesthetics
fig_cat_incidents.update_layout(
    showlegend=False,  # No need for legend as color maps directly to x-axis categories
    xaxis_title='Crime Category',
    yaxis_title='Number of Incidents',
    title_font_size=18,
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_x=0.5  # Center the title
)

# Add a visible border to the bars and position text labels
fig_cat_incidents.update_traces(
    marker_line_width=1,
    marker_line_color='black',
    textposition='outside',  # Position the count labels above the bars
    textfont_size=12
)

fig_cat_incidents.show()

"""**2. Explore Demographics of Offenders and Victims:**

Examine the distributions of `Offender_Age`, `Victim_Age`, `Offender_Gender`, `Victim_Gender`, `Offender_Race`, and `Victim_Race` to identify common demographic profiles.

**2.1. Data Cleaning and transformation**
"""

# --- Data Cleaning: Shorten long race category name (ensure consistency) ---
LONG_RACE_LABEL = 'NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER'
SHORT_RACE_LABEL = 'Native Hawaiian/PI' # Shorter, more manageable label

if LONG_RACE_LABEL in df['Offender_Race'].unique():
    df['Offender_Race'] = df['Offender_Race'].replace(LONG_RACE_LABEL, SHORT_RACE_LABEL)
    print(f"Shortened '{LONG_RACE_LABEL}' to '{SHORT_RACE_LABEL}' in Offender_Race for this analysis.")

if LONG_RACE_LABEL in df['Victim_Race'].unique():
    df['Victim_Race'] = df['Victim_Race'].replace(LONG_RACE_LABEL, SHORT_RACE_LABEL)
    print(f"Shortened '{LONG_RACE_LABEL}' to '{SHORT_RACE_LABEL}' in Victim_Race for this analysis.")


# --- CRITICAL: Robust Cleaning for Categorical Columns (Gender, Race) ---
# Apply strip() and upper() to ensure exact string matching for consistency
for col in ['Offender_Gender', 'Victim_Gender', 'Offender_Race', 'Victim_Race']:
    if col in df.columns:
        df[col] = df[col].astype(str).str.strip().str.upper()
        # Replace 'NAN' string (from .astype(str)) with actual pandas NaN for proper dropna behavior later
        df[col] = df[col].replace('NAN', np.nan)


# --- Colorblind-Friendly Palettes ---
# For sequential data (e.g., age histograms), Viridis is excellent.
COLOR_SCALE_SEQUENTIAL = px.colors.sequential.Viridis

# For discrete/categorical data, using px.colors.qualitative.Vivid for a good range of distinct colors.
# This palette is generally vibrant and colorblind-friendly for multiple categories.
COLOR_SCALE_DISCRETE_GENERAL = px.colors.qualitative.Vivid


# --- Debugging: Print unique values after cleaning to verify keys for color maps ---
print("\n--- Unique values after cleaning for demographic columns ---")
print(f"Offender_Gender unique: {df['Offender_Gender'].dropna().unique().tolist()}")
print(f"Victim_Gender unique: {df['Victim_Gender'].dropna().unique().tolist()}")
print(f"Offender_Race unique: {df['Offender_Race'].dropna().unique().tolist()}")
print(f"Victim_Race unique: {df['Victim_Race'].dropna().unique().tolist()}")

"""**2.2.1. Offender Age Analysis**

This section analyzes the distribution of offender ages using summary statistics (mean, median, mode, etc.) and visualizes the data with a histogram and a box plot. These visuals help reveal patterns, spread, and central tendencies in offender age, with annotations to highlight the mean and median values.
"""

# --- 1. Offender Age Analysis ---
print("\n--- Offender Age Statistics ---")

# Drop NaN values for accurate statistical calculations
offender_age_clean = df['Offender_Age'].dropna()

if not offender_age_clean.empty:
    print(f"Mean Offender Age: {offender_age_clean.mean():.2f}")
    print(f"Median Offender Age: {offender_age_clean.median():.2f}")
    print(f"Mode Offender Age: {offender_age_clean.mode().tolist()}")  # Mode can return multiple values
    print(f"Standard Deviation Offender Age: {offender_age_clean.std():.2f}")
    print(f"Offender Age Quartiles:\n{offender_age_clean.quantile([0.25, 0.5, 0.75])}")

    # Plotly Histogram for Offender Age
    fig_hist_offender_age = px.histogram(
        offender_age_clean,
        x="Offender_Age",
        nbins=50,  # Number of bins for the histogram
        title='Distribution of Offender Age',
        labels={'Offender_Age': 'Age'},
        color_discrete_sequence=[COLOR_SCALE_DISCRETE_GENERAL[0]],
        template="plotly_white",
        marginal="box"  # Add a box plot to the margin
    )

    fig_hist_offender_age.update_layout(
        xaxis_title='Offender Age',
        yaxis_title='Frequency',
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_font_size=18,
        title_x=0.5,  # Center the title
        hovermode="x unified"
    )

    # Optionally annotate mean age on the histogram
    fig_hist_offender_age.add_annotation(
        x=offender_age_clean.mean(),
        y=0,
        text=f"Mean: {offender_age_clean.mean():.1f}",
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40,
        bgcolor='rgba(255,255,255,0.7)',
        font=dict(size=12)
    )

    fig_hist_offender_age.show()

    # Plotly Box Plot for Offender Age
    fig_box_offender_age = px.box(
        offender_age_clean,
        y="Offender_Age",
        title='Box Plot of Offender Age',
        labels={'Offender_Age': 'Age'},
        color_discrete_sequence=[COLOR_SCALE_DISCRETE_GENERAL[1]],
        template="plotly_white"
    )

    fig_box_offender_age.update_layout(
        yaxis_title='Offender Age',
        xaxis_title='',
        yaxis_title_font_size=14,
        title_font_size=18,
        title_x=0.5  # Center the title
    )

    # Optionally annotate median on the box plot
    fig_box_offender_age.add_annotation(
        x=0,
        y=offender_age_clean.median(),
        text=f"Median: {offender_age_clean.median():.1f}",
        showarrow=True,
        arrowhead=1,
        ax=40,
        ay=0,
        bgcolor='rgba(255,255,255,0.7)',
        font=dict(size=12)
    )

    fig_box_offender_age.show()

else:
    print("Offender_Age column is empty or contains only missing values.")

"""**2.2.2. Victim Age Analysis**

This section explores the distribution of victim ages through statistical summaries and visualizations. A histogram and box plot highlight patterns in age, with annotations for the mean and median to support clearer interpretation of the data.
"""

# --- 2. Victim Age Analysis ---
print("\n--- Victim Age Statistics ---")
victim_age_clean = df['Victim_Age'].dropna()

if not victim_age_clean.empty:
    print(f"Mean Victim Age: {victim_age_clean.mean():.2f}")
    print(f"Median Victim Age: {victim_age_clean.median():.2f}")
    print(f"Mode Victim Age: {victim_age_clean.mode().tolist()}")
    print(f"Standard Deviation Victim Age: {victim_age_clean.std():.2f}")
    print(f"Victim Age Quartiles:\n{victim_age_clean.quantile([0.25, 0.5, 0.75])}")

    # Use a color universally distinguishable (colorblind-safe) like a strong blue
    victim_color = '#0072B2'  # CUD blue (colorblind-friendly)

    # Plotly Histogram for Victim Age
    fig_hist_victim_age = px.histogram(
        victim_age_clean,
        x="Victim_Age",
        nbins=50,
        title='Distribution of Victim Age',
        labels={'Victim_Age': 'Age'},
        color_discrete_sequence=[victim_color],
        template="plotly_white",
        marginal="box"
    )

    fig_hist_victim_age.update_layout(
        xaxis_title='Victim Age',
        yaxis_title='Frequency',
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_font_size=18,
        hovermode="x unified",
        title_x=0.5
    )

    fig_hist_victim_age.add_annotation(
        x=victim_age_clean.mean(),
        y=0,
        text=f"Mean: {victim_age_clean.mean():.1f}",
        showarrow=True,
        arrowhead=1,
        ax=0,
        ay=-40,
        bgcolor='rgba(255,255,255,0.7)',
        font=dict(size=12)
    )

    fig_hist_victim_age.show()

    # Box Plot for Victim Age
    fig_box_victim_age = px.box(
        victim_age_clean,
        y="Victim_Age",
        title='Box Plot of Victim Age',
        labels={'Victim_Age': 'Age'},
        color_discrete_sequence=[victim_color],
        template="plotly_white"
    )

    fig_box_victim_age.update_layout(
        yaxis_title='Victim Age',
        xaxis_title='',
        yaxis_title_font_size=14,
        title_font_size=18,
        title_x=0.5
    )

    fig_box_victim_age.add_annotation(
        x=0,
        y=victim_age_clean.median(),
        text=f"Median: {victim_age_clean.median():.1f}",
        showarrow=True,
        arrowhead=1,
        ax=40,
        ay=0,
        bgcolor='rgba(255,255,255,0.7)',
        font=dict(size=12)
    )

    fig_box_victim_age.show()

else:
    print("Victim_Age column is empty or contains only missing values.")

"""**2.2.3 Offender Gender Analysis**

This section presents the frequency and percentage distribution of offender gender using a styled table and a color-coded bar chart for visual clarity. The chart effectively communicates the gender breakdown in the dataset.
"""

# --- 3. Offender Gender Analysis ---
print("\n--- Offender Gender Distribution ---")
offender_gender_counts = df['Offender_Gender'].value_counts().reset_index()
offender_gender_counts.columns = ['Gender', 'Count']
offender_gender_counts['Percentage (%)'] = (offender_gender_counts['Count'] / offender_gender_counts['Count'].sum()) * 100

display(
    offender_gender_counts.style
    .background_gradient(cmap='Blues', subset=['Count'])
    .format({"Percentage (%)": "{:.2f}%"})
    .set_properties(**{'text-align': 'center'})
    .set_caption("Frequency and Proportion of Offender Gender")
)

# Plotly Bar Chart for Offender Gender
fig_bar_offender_gender = px.bar(
    offender_gender_counts,
    x='Gender',
    y='Count',
    labels={'Gender': 'Offender Gender', 'Count': 'Count'},
    title='Distribution of Offender Gender',
    color='Gender', # Color by gender category
    color_discrete_sequence=COLOR_SCALE_DISCRETE_GENERAL, # Using general discrete palette
    template="plotly_white",
    text_auto=True,
    opacity=1
)
fig_bar_offender_gender.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    hovermode="x unified",
    title_x=0.5,
    showlegend=False # No need for legend as color maps directly to x-axis
)
fig_bar_offender_gender.update_traces(marker_line_width=1, marker_line_color='black')
fig_bar_offender_gender.show()

"""**2.2.4 Victim Gender Analysis**

This section summarizes the distribution of victim gender using a percentage table and a bar chart, highlighting gender-based patterns in victimization.
"""

# --- 4. Victim Gender Analysis ---
print("\n--- Victim Gender Distribution ---")
victim_gender_counts = df['Victim_Gender'].value_counts().reset_index()
victim_gender_counts.columns = ['Gender', 'Count']
victim_gender_counts['Percentage (%)'] = (victim_gender_counts['Count'] / victim_gender_counts['Count'].sum()) * 100

display(
    victim_gender_counts.style
    .background_gradient(cmap='Blues', subset=['Count'])
    .format({"Percentage (%)": "{:.2f}%"})
    .set_properties(**{'text-align': 'center'})
    .set_caption("Frequency and Proportion of Victim Gender")
)

# Plotly Bar Chart for Victim Gender
fig_bar_victim_gender = px.bar(
    victim_gender_counts,
    x='Gender',
    y='Count',
    labels={'Gender': 'Victim Gender', 'Count': 'Count'},
    title='Distribution of Victim Gender',
    color='Gender', # Color by gender category
    color_discrete_sequence=COLOR_SCALE_DISCRETE_GENERAL, # Using general discrete palette
    template="plotly_white",
    text_auto=True,
    opacity=1
)
fig_bar_victim_gender.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    hovermode="x unified",
    title_x=0.5,
    showlegend=False # No need for legend as color maps directly to x-axis
)
fig_bar_victim_gender.update_traces(marker_line_width=1, marker_line_color='black')
fig_bar_victim_gender.show()

"""**2.2.5 Offender Race Analysis**

This section explores the racial distribution of offenders through a frequency table and a color-coded bar chart, offering insights into demographic patterns among offenders.
"""

# --- 5. Offender Race Analysis ---
print("\n--- Offender Race Distribution ---")
offender_race_counts = df['Offender_Race'].value_counts().reset_index()
offender_race_counts.columns = ['Race', 'Count']
offender_race_counts['Percentage (%)'] = (offender_race_counts['Count'] / offender_race_counts['Count'].sum()) * 100

display(
    offender_race_counts.style
    .background_gradient(cmap='Blues', subset=['Count'])
    .format({"Percentage (%)": "{:.2f}%"})
    .set_properties(**{'text-align': 'center'})
    .set_caption("Frequency and Proportion of Offender Race")
)

# Plotly Bar Chart for Offender Race
fig_bar_offender_race = px.bar(
    offender_race_counts,
    x='Race',
    y='Count',
    labels={'Race': 'Offender Race', 'Count': 'Count'},
    title='Distribution of Offender Race',
    color='Race', # Color by race category
    color_discrete_sequence=COLOR_SCALE_DISCRETE_GENERAL, # Using general discrete palette for multiple races
    template="plotly_white",
    text_auto=True,
    opacity=1
)
fig_bar_offender_race.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    hovermode="x unified",
    title_x=0.5,
    showlegend=False # No need for legend as color maps directly to x-axis
)
fig_bar_offender_race.update_traces(marker_line_width=1, marker_line_color='black')
fig_bar_offender_race.show()

"""**2.2.6 Victim Race Analysis**

This section visualizes the distribution of victim races using a summary table and bar chart, highlighting racial patterns among crime victims.
"""

# --- 6. Victim Race Analysis ---
print("\n--- Victim Race Distribution ---")
victim_race_counts = df['Victim_Race'].value_counts().reset_index()
victim_race_counts.columns = ['Race', 'Count']
victim_race_counts['Percentage (%)'] = (victim_race_counts['Count'] / victim_race_counts['Count'].sum()) * 100

display(
    victim_race_counts.style
    .background_gradient(cmap='Blues', subset=['Count'])
    .format({"Percentage (%)": "{:.2f}%"})
    .set_properties(**{'text-align': 'center'})
    .set_caption("Frequency and Proportion of Victim Race")
)

# Plotly Bar Chart for Victim Race
fig_bar_victim_race = px.bar(
    victim_race_counts,
    x='Race',
    y='Count',
    labels={'Race': 'Victim Race', 'Count': 'Count'},
    title='Distribution of Victim Race',
    color='Race', # Color by race category
    color_discrete_sequence=COLOR_SCALE_DISCRETE_GENERAL, # Using general discrete palette for multiple races
    template="plotly_white",
    text_auto=True,
    opacity=1
)
fig_bar_victim_race.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    hovermode="x unified",
    title_x=0.5,
    showlegend=False # No need for legend as color maps directly to x-axis
)
fig_bar_victim_race.update_traces(marker_line_width=1, marker_line_color='black')
fig_bar_victim_race.show()

"""**3. Investigate Relationships between Offender/Victim Characteristics and Crime Category:**

Determine if there are noticeable patterns or associations between offender/victim demographics (e.g., age, gender, race) and the Category of crime or Victim_Fatal_Status.

**3.1. Data Cleaning and transformation**

This block performs essential data cleaning and formatting to standardize categorical values (e.g., gender, race, fatal status) and ensures consistent labeling for accurate visualizations and color mapping.
"""

# --- Data Cleaning: Shorten long race category name (ensure consistency) ---
LONG_RACE_LABEL = 'NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER'
SHORT_RACE_LABEL = 'Native Hawaiian/PI' # Sorter, more manageable label

if LONG_RACE_LABEL in df['Offender_Race'].unique():
    df['Offender_Race'] = df['Offender_Race'].replace(LONG_RACE_LABEL, SHORT_RACE_LABEL)
    print(f"Shortened '{LONG_RACE_LABEL}' to '{SHORT_RACE_LABEL}' in Offender_Race for this analysis.")

if LONG_RACE_LABEL in df['Victim_Race'].unique():
    df['Victim_Race'] = df['Victim_Race'].replace(LONG_RACE_LABEL, SHORT_RACE_LABEL)
    print(f"Shortened '{LONG_RACE_LABEL}' to '{SHORT_RACE_LABEL}' in Victim_Race for this analysis.")


# --- CRITICAL: Robust Cleaning for Categorical Columns (Gender, Fatal Status, Category, Race) ---
# Apply strip() and upper() to ensure exact string matching for color maps and consistency
for col in ['Offender_Gender', 'Victim_Gender', 'Victim_Fatal_Status', 'Category', 'Offender_Race', 'Victim_Race']:
    if col in df.columns:
        # Convert to string first to handle potential non-string types (like float NaNs)
        df[col] = df[col].astype(str).str.strip().str.upper()
        # Replace 'NAN' string (from .astype(str)) with actual pandas NaN for proper dropna behavior later
        df[col] = df[col].replace('NAN', np.nan)


# --- Custom Color Maps for Specific Categorical Variables ---
# These colors are chosen for high contrast and colorblind-friendliness.
# Keys must EXACTLY match the cleaned, uppercase values in your DataFrame.

# Using very distinct and darker colors for binary categories like Gender
COLOR_MAP_GENDER = {
    'MALE': '#00008B',   # Dark Blue
    'FEMALE': '#8B0000', # Dark Red
    'OTHER': '#7f7f7f',  # Grey for any other unexpected gender categories
    'UNKNOWN': '#7f7f7f', # Grey for explicitly unknown if present
    'NOT APPLICABLE': '#7f7f7f' # Grey for 'Not Applicable' if present
}

# Using very distinct and darker colors for Fatal Status
COLOR_MAP_FATAL_STATUS = {
    'NON-FATAL': '#006400', # Dark Green
    'FATAL': '#B22222',     # Firebrick Red (very distinct from dark green)
    'OTHER': '#7f7f7f',     # Grey for any other unexpected fatal status categories
    'UNKNOWN': '#7f7f7f'    # Grey for explicitly unknown if present
}

# General discrete palette for other categorical columns (like Race or Category itself in Box plots)
# Using px.colors.qualitative.Vivid for a good range of distinct colors.
COLOR_SCALE_DISCRETE_GENERAL = px.colors.qualitative.Vivid

# Sequential color scale for heatmaps (Viridis is colorblind-friendly)
COLOR_SCALE_HEATMAP = px.colors.sequential.Viridis


# --- Debugging: Print unique values after cleaning to verify keys for color maps ---
print("\n--- Unique values after cleaning for color mapping verification ---")
print(f"Offender_Gender unique: {df['Offender_Gender'].dropna().unique().tolist()}")
print(f"Victim_Gender unique: {df['Victim_Gender'].dropna().unique().tolist()}")
print(f"Victim_Fatal_Status unique: {df['Victim_Fatal_Status'].dropna().unique().tolist()}")
print(f"Category unique: {df['Category'].dropna().unique().tolist()}")
print(f"Offender_Race unique: {df['Offender_Race'].dropna().unique().tolist()}")
print(f"Victim_Race unique: {df['Victim_Race'].dropna().unique().tolist()}")

"""**3.2.1. Crime Category vs. Offender Gender (Heatmap)**

This section creates a heatmap to visualize the relationship between crime categories and offender gender. By using a cross-tabulation of frequencies, it reveals co-occurrence patterns and highlights which crimes are more associated with specific gender categories. The Viridis color scale ensures accessibility and intuitive intensity representation.
"""

# --- 1. Crime Category vs. Offender Gender (Heatmap) ---
print("\n--- Crime Category vs. Offender Gender (Heatmap) ---")
# Create a cross-tabulation for the heatmap
df_clean_cat_off_gender = df.dropna(subset=['Category', 'Offender_Gender'])
gender_category_crosstab = pd.crosstab(df_clean_cat_off_gender['Category'], df_clean_cat_off_gender['Offender_Gender'])

fig_cat_off_gender_heatmap = px.imshow(
    gender_category_crosstab,
    text_auto=True, # Show values in cells
    labels=dict(x="Offender Gender", y="Crime Category", color="Number of Incidents"),
    x=gender_category_crosstab.columns.tolist(),
    y=gender_category_crosstab.index.tolist(),
    color_continuous_scale=COLOR_SCALE_HEATMAP, # Use sequential scale for heatmap intensity
    title='Co-occurrence of Crime Categories and Offender Gender',
    template="plotly_white"
)
fig_cat_off_gender_heatmap.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    title_x=0.5, # Center the title
)
fig_cat_off_gender_heatmap.show()

"""**3.2.2 2. Crime Category vs. Victim Gender (Heatmap)**

This section visualizes the distribution of crime categories across victim genders using a heatmap. The cross-tabulated data highlights the frequency of incidents for each crime type and gender combination. The Viridis scale is applied to reflect intensity clearly, helping identify patterns of victimization by gender across different crime categories.
"""

# --- 2. Crime Category vs. Victim Gender (Heatmap) ---
print("\n--- Crime Category vs. Victim Gender (Heatmap) ---")
df_clean_cat_vic_gender = df.dropna(subset=['Category', 'Victim_Gender'])
victim_gender_category_crosstab = pd.crosstab(df_clean_cat_vic_gender['Category'], df_clean_cat_vic_gender['Victim_Gender'])

fig_cat_vic_gender_heatmap = px.imshow(
    victim_gender_category_crosstab,
    text_auto=True,
    labels=dict(x="Victim Gender", y="Crime Category", color="Number of Incidents"),
    x=victim_gender_category_crosstab.columns.tolist(),
    y=victim_gender_category_crosstab.index.tolist(),
    color_continuous_scale=COLOR_SCALE_HEATMAP,
    title='Co-occurrence of Crime Categories and Victim Gender',
    template="plotly_white"
)
fig_cat_vic_gender_heatmap.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    title_x=0.5,
)
fig_cat_vic_gender_heatmap.show()

"""**3.2.3 Offender Age Distribution by Crime Category (Box Plot)**

This box plot illustrates the spread of offender ages across various crime categories. It reveals medians, quartiles, and outliers, helping to identify age-related trends in criminal behavior. Median ages for each category are annotated for clearer comparison.
"""

# --- 3. Offender Age Distribution by Crime Category (Box Plot) ---
print("\n--- Offender Age Distribution by Crime Category ---")
df_clean_off_age_cat = df.dropna(subset=['Offender_Age', 'Category'])

if not df_clean_off_age_cat.empty:
    # Use colorblind-friendly palette
    cud_colors = ['#0072B2', '#E69F00', '#009E73', '#D55E00', '#CC79A7', '#F0E442', '#56B4E9']

    fig_off_age_by_cat = px.box(
        df_clean_off_age_cat,
        x='Category',
        y='Offender_Age',
        title='Offender Age Distribution Across Crime Categories',
        labels={'Category': 'Crime Category', 'Offender_Age': 'Offender Age'},
        color='Category',
        color_discrete_sequence=cud_colors,
        template="plotly_white"
    )

    fig_off_age_by_cat.update_layout(
        xaxis_title='Crime Category',
        yaxis_title='Offender Age',
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_font_size=18,
        title_x=0.5,
        hovermode="x unified",
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1,
            title_font_size=12,
            font_size=10,
            itemsizing='constant'
        )
    )

    # Compute and annotate median for each category
    category_medians = df_clean_off_age_cat.groupby('Category')['Offender_Age'].median()

    for i, (category, median_val) in enumerate(category_medians.items()):
        fig_off_age_by_cat.add_annotation(
            x=category,
            y=median_val,
            text=f"Median: {median_val:.1f}",
            showarrow=True,
            arrowhead=1,
            ax=0,
            ay=-25,
            font=dict(size=11),
            bgcolor='rgba(255,255,255,0.7)'
        )

    fig_off_age_by_cat.show()

else:
    print("Required data is missing: Offender_Age or Category column has only missing values.")

"""**3.2.4. Victim Age Distribution by Crime Category (Box Plot)**

This plot displays the distribution of victim ages across crime categories, highlighting age ranges, outliers, and central tendencies. Each median age is labeled to support clearer comparisons between crime types.
"""

# --- 4. Victim Age Distribution by Crime Category (Box Plot) ---
print("\n--- Victim Age Distribution by Crime Category ---")
df_clean_vic_age_cat = df.dropna(subset=['Victim_Age', 'Category'])

if not df_clean_vic_age_cat.empty:
    # Use colorblind-friendly CUD palette
    cud_colors = ['#0072B2', '#E69F00', '#009E73', '#D55E00', '#CC79A7', '#F0E442', '#56B4E9']

    fig_vic_age_by_cat = px.box(
        df_clean_vic_age_cat,
        x='Category',
        y='Victim_Age',
        title='Victim Age Distribution Across Crime Categories',
        labels={'Category': 'Crime Category', 'Victim_Age': 'Victim Age'},
        color='Category',
        color_discrete_sequence=cud_colors,
        template="plotly_white"
    )

    fig_vic_age_by_cat.update_layout(
        xaxis_title='Crime Category',
        yaxis_title='Victim Age',
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_font_size=18,
        title_x=0.5,
        hovermode="x unified",
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1,
            title_font_size=12,
            font_size=10,
            itemsizing='constant'
        )
    )

    # Compute and annotate median for each category
    category_medians = df_clean_vic_age_cat.groupby('Category')['Victim_Age'].median()

    for category, median_val in category_medians.items():
        fig_vic_age_by_cat.add_annotation(
            x=category,
            y=median_val,
            text=f"Median: {median_val:.1f}",
            showarrow=True,
            arrowhead=1,
            ax=0,
            ay=-25,
            font=dict(size=11),
            bgcolor='rgba(255,255,255,0.7)'
        )

    fig_vic_age_by_cat.show()

else:
    print("Victim_Age or Category column is empty or contains only missing values.")

"""**3.2.5. Offender Race vs. Victim Race (Co-occurrence Heatmap)**

This heatmap visualizes how often different combinations of offender and victim races occur, helping to identify patterns or disparities in inter-racial or intra-racial crime incidents.
"""

# --- 5. Offender Race vs. Victim Race (Co-occurrence Heatmap) ---
print("\n--- Offender Race vs. Victim Race Co-occurrence ---")
df_clean_races = df.dropna(subset=['Offender_Race', 'Victim_Race'])
race_crosstab = pd.crosstab(df_clean_races['Offender_Race'], df_clean_races['Victim_Race'])

fig_race_heatmap = px.imshow(
    race_crosstab,
    text_auto=True,
    labels=dict(x="Victim Race", y="Offender Race", color="Count"),
    x=race_crosstab.columns.tolist(),
    y=race_crosstab.index.tolist(),
    color_continuous_scale=COLOR_SCALE_HEATMAP, # Viridis is good for heatmaps
    title='Co-occurrence of Offender Race and Victim Race',
    template="plotly_white"
)
fig_race_heatmap.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    title_x=0.5
)
fig_race_heatmap.show()

"""**3.2.6. Crime Category vs. Victim Fatal Status (Heatmap)**

This heatmap highlights how frequently each crime category is associated with different victim fatal outcomes, revealing trends in the severity of incidents.
"""

# --- 6. Crime Category vs. Victim Fatal Status (Heatmap) ---
print("\n--- Crime Category vs. Victim Fatal Status (Heatmap) ---")
df_clean_cat_fatal = df.dropna(subset=['Category', 'Victim_Fatal_Status'])
fatal_status_category_crosstab = pd.crosstab(df_clean_cat_fatal['Category'], df_clean_cat_fatal['Victim_Fatal_Status'])

fig_cat_fatal_status_heatmap = px.imshow(
    fatal_status_category_crosstab,
    text_auto=True,
    labels=dict(x="Victim Fatal Status", y="Crime Category", color="Number of Incidents"),
    x=fatal_status_category_crosstab.columns.tolist(),
    y=fatal_status_category_crosstab.index.tolist(),
    color_continuous_scale=COLOR_SCALE_HEATMAP,
    title='Co-occurrence of Crime Categories and Victim Fatal Status',
    template="plotly_white"
)
fig_cat_fatal_status_heatmap.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    title_x=0.5,
)
fig_cat_fatal_status_heatmap.show()

"""**4. Assess the Outcome of Incidents:**

Analyze the Disposition to understand the typical outcomes of reported incidents.
EDA Techniques: Frequency counts, proportions.
Visualizations: Plotly Bar charts (px.bar).

**4.1. Data Cleaning and transformation**

This step standardizes the 'Disposition' column by converting values to uppercase and trimming whitespace, ensuring consistent formatting. It also replaces string 'NAN' with proper NaN to maintain data integrity during analysis.
"""

# --- CRITICAL: Robust Cleaning for 'Disposition' Column ---
# Apply strip() and upper() to ensure exact string matching for consistency
if 'Disposition' in df.columns:
    df['Disposition'] = df['Disposition'].astype(str).str.strip().str.upper()
    # Replace 'NAN' string (from .astype(str)) with actual pandas NaN for proper dropna behavior later
    df['Disposition'] = df['Disposition'].replace('NAN', np.nan)

# --- Colorblind-Friendly Discrete Palette ---
# Using px.colors.qualitative.Vivid for a good range of distinct colors.
COLOR_SCALE_DISCRETE_GENERAL = px.colors.qualitative.Vivid


# --- Debugging: Print unique values after cleaning ---
print("\n--- Unique values after cleaning for outcome columns ---")
print(f"Disposition unique: {df['Disposition'].dropna().unique().tolist()}")

"""**4.2.1 Disposition Analysis**

This analysis explores how incidents are concluded by examining the distribution of disposition outcomes using both tabular summary and bar chart visualization.
"""

# --- 1. Disposition Analysis ---
print("\n--- Disposition Distribution ---")
disposition_counts = df['Disposition'].value_counts().reset_index()
disposition_counts.columns = ['Disposition', 'Count']
disposition_counts['Percentage (%)'] = (disposition_counts['Count'] / disposition_counts['Count'].sum()) * 100

display(
    disposition_counts.style
    .background_gradient(cmap='Greens', subset=['Count']) # Using Greens for this section
    .format({"Percentage (%)": "{:.2f}%"})
    .set_properties(**{'text-align': 'center'})
    .set_caption("Frequency and Proportion of Incident Disposition")
    .set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#4CAF50'), ('color', 'white'), ('font-weight', 'bold')]},
        {'selector': 'td', 'props': [('padding', '8px'), ('border', '1px solid #ddd')]},
        {'selector': 'table', 'props': [('width', '100%'), ('border-collapse', 'collapse')]}
    ])
    .hide(axis="index") # Hide the default pandas index for a cleaner look
)

# Plotly Bar Chart for Disposition
fig_disposition = px.bar(
    disposition_counts,
    x='Disposition',
    y='Count',
    labels={'Disposition': 'Incident Disposition', 'Count': 'Number of Incidents'},
    title='Distribution of Incident Disposition',
    color='Disposition', # Color by disposition category (each bar gets a unique color)
    color_discrete_sequence=COLOR_SCALE_DISCRETE_GENERAL, # Use a general discrete palette
    template="plotly_white",
    text_auto=True, # Automatically add text labels (counts) on bars
    opacity=1
)
fig_disposition.update_layout(
    xaxis_title_font_size=14,
    yaxis_title_font_size=14,
    title_font_size=18,
    hovermode="x unified",
    title_x=0.5,
    showlegend=False # No need for legend as color maps directly to x-axis categories
)
fig_disposition.update_traces(marker_line_width=1, marker_line_color='black')
fig_disposition.show()